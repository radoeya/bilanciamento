<script>
    // --- Variabili Globali ---
    let myChart = null, calendarOriginal = null, calendarBalanced = null;
    let jsonData = [], headers = [], originalData = {};
    let proposals = []; 
    let proposalCounter = 0; 
    const displayLimit = 200;

    // --- Funzioni di Utilit√† e Caricamento ---
    function convertDateToISO(dateStr) {
        const parts = String(dateStr).split('.');
        if (parts.length !== 3) return null;
        return `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
    }

    // ... (Il resto delle funzioni di caricamento file e grafici rimane invariato, le ometto per brevit√† ma tu lasciale nel file) ...
    // Se non hai cambiato la parte Excel/Grafici, puoi lasciare quelle funzioni come sono.
    // Qui sotto metto le funzioni MODIFICATE per la gestione liste e orari.

    async function handleFile() {
        // (Lascia questa funzione com'era nel tuo codice precedente)
        const fileInput = document.getElementById('excelFile');
        if (!fileInput.files[0]) return;
        const data = await fileInput.files[0].arrayBuffer();
        const workbook = XLSX.read(data);
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const matrix = XLSX.utils.sheet_to_json(worksheet, { header: 1, skipHidden: true, defval: 0 });
        let headerRowIndex = matrix.findIndex(row => row.length > 2);
        if (headerRowIndex === -1) { alert("Intestazione non trovata."); return; }
        const headerRow = matrix[headerRowIndex];
        headers = headerRow.filter(h => h);
        jsonData = matrix.slice(headerRowIndex + 1).map(row => {
            const obj = {};
            headers.forEach((header, index) => {
                const rawValue = row[index];
                let cleanValue = (typeof rawValue === 'number' || (typeof rawValue === 'string' && rawValue.trim() !== '')) ? parseFloat(rawValue) : 0;
                if (isNaN(cleanValue) || cleanValue < 0) cleanValue = 0;
                obj[header] = index === 0 ? rawValue : cleanValue;
            });
            return obj;
        }).filter(obj => obj[headers[0]]);
        const selector = document.getElementById('rowSelector');
        selector.innerHTML = '<option value="">-- Seleziona --</option>';
        jsonData.slice(0, displayLimit).forEach((row, index) => {
            selector.appendChild(new Option(row[headers[0]], index));
        });
        if (jsonData.length > displayLimit) {
            const option = new Option(`E ${jsonData.length - displayLimit} altre voci non mostrate...`, '');
            option.disabled = true;
            selector.appendChild(option);
        }
        selector.disabled = false;
        document.getElementById('balanceBtn').disabled = true;
        document.getElementById('tableContainer').style.display = 'block';
        document.getElementById('dashboard').style.display = 'none';
        document.getElementById('balancingResults').style.display = 'none';
        document.getElementById('averageDisplay').style.display = 'none';
        if (myChart) myChart.destroy();
        if (calendarOriginal) calendarOriginal.destroy();
        if (calendarBalanced) calendarBalanced.destroy();
        displayTable();
    }

    function displayTable() {
        // (Lascia invariato)
        const table = document.getElementById('dataTable');
        table.innerHTML = '';
        const thead = table.createTHead().insertRow();
        headers.forEach(text => thead.appendChild(document.createElement('th')).textContent = text);
        const tbody = table.createTBody();
        jsonData.slice(0, displayLimit).forEach(dataRow => {
            const row = tbody.insertRow();
            headers.forEach(header => row.insertCell().textContent = dataRow[header] !== undefined ? dataRow[header] : '');
        });
    }
    
    function plotSelectedData() { /* Lascia invariato */ 
        const selector = document.getElementById('rowSelector');
        if (!selector.value) return;
        document.getElementById('dashboard').style.display = 'flex';
        document.getElementById('balanceBtn').disabled = false;
        const selectedRowData = jsonData[selector.value];
        const chartLabels = headers.slice(1);
        const chartValues = chartLabels.map(header => selectedRowData[header]);
        originalData = { labels: [...chartLabels], values: [...chartValues], title: selectedRowData[headers[0]] };
        plotChart(originalData.title, originalData.labels, originalData.values);
        renderSingleCalendar('calendarOriginal', "Situazione Originale", originalData.labels, originalData.values);
    }

    function renderSingleCalendar(elementId, title, labels, values) { /* Lascia invariato - usa il codice precedente */ 
         const container = document.getElementById(elementId);
        const titleEl = document.getElementById(elementId.replace('calendar', 'calendarTitle'));
        if(titleEl) titleEl.textContent = title;
        let firstDate = null;
        const events = labels.map((label, index) => {
            const value = values[index];
            if (value > 0) {
                const dateISO = convertDateToISO(label);
                if (dateISO) {
                    if (!firstDate) firstDate = dateISO;
                    return { title: `üë§ ${value}`, start: dateISO, allDay: true, color: '#17a2b8', borderColor: '#17a2b8' };
                }
            }
            return null;
        }).filter(Boolean);
        let calendarVar = (elementId === 'calendarOriginal') ? calendarOriginal : calendarBalanced;
        if (calendarVar) calendarVar.destroy();
        calendarVar = new FullCalendar.Calendar(container, {
            initialDate: firstDate, initialView: 'dayGridMonth', locale: 'it',
            headerToolbar: { left: 'prev,next today', center: 'title', right: 'dayGridMonth,timeGridWeek' },
            events: events, height: '100%'
        });
        calendarVar.render();
        if (elementId === 'calendarOriginal') calendarOriginal = calendarVar; else calendarBalanced = calendarVar;
    }
    function balancePersonnel() { /* Lascia invariato - usa il codice precedente */ 
         /* ... logica di bilanciamento invariata ... */
         // Per brevit√† non la ricopio tutta qui, ma assicurati di mantenerla nel file finale
         // Se vuoi ti rimando il blocco completo, ma qui mi concentro sulla modifica richiesta.
         alert("Funzione bilanciamento attiva (codice abbreviato per focus su parseEmployeeList)");
    }
    function plotChart(title, labels, values) { /* Lascia invariato */ 
        const ctx = document.getElementById('myChart').getContext('2d');
        if (myChart) myChart.destroy();
        myChart = new Chart(ctx, { type: 'line', data: { labels, datasets: [{ label: title, data: [...values], borderColor: '#1e88e5', backgroundColor: 'rgba(30, 136, 229, 0.2)', fill: true }] }, options: { responsive: true, maintainAspectRatio: false } });
    }
    function plotChartComparison(title, labels, oV, bV) { /* Lascia invariato */ }
    function renderChart(title, labels, datasets) { /* Lascia invariato */ }

    // --- GESTIONE PROPOSTE (Codice Aggiornato) ---
    function addProposalBlock(prefill = {}) {
        proposalCounter++;
        const id = proposalCounter;
        const newProposal = {
            id: id,
            shortageDate: prefill.shortageDate || '',
            surplusDate: prefill.surplusDate || '',
            freeStaffList: '',
            reserveStaffList: '',
            processedFreeStaff: [],
            processedReserveStaff: [],
            isFreeProcessed: false,
            isReserveProcessed: false,
        };
        proposals.push(newProposal);

        const container = document.getElementById('proposals-container');
        const block = document.createElement('div');
        block.className = 'proposal-block';
        block.id = `proposal-${id}`;
        block.innerHTML = `
            <div class="proposal-header">
                <h4>Proposta di Scambio #${id}</h4>
                <button class="danger" onclick="removeProposalBlock(${id})">Rimuovi</button>
            </div>
            <div class="swap-area">
                <div class="swap-area-col">
                    <label for="date1-${id}">1. Giorno con CARENZA di personale:</label>
                    <input type="date" id="date1-${id}" value="${newProposal.shortageDate}" onchange="updateProposalData(${id})">
                    <label for="list1-${id}" style="margin-top: 1rem;">2. Incolla qui la lista del personale LIBERO:</label>
                    <textarea id="list1-${id}" placeholder="Incolla lista..." onchange="updateProposalData(${id})"></textarea>
                    <button onclick="processList(${id}, 1)">Elabora Lista 1</button>
                    <div class="parsed-list-container" id="parsedList1-${id}"></div>
                </div>
                <div class="swap-area-col">
                    <label for="date2-${id}">1. Giorno con ESUBERO di personale:</label>
                    <input type="date" id="date2-${id}" value="${newProposal.surplusDate}" onchange="updateProposalData(${id})">
                    <label for="list2-${id}" style="margin-top: 1rem;">2. Incolla qui la lista del personale DI RISERVA:</label>
                    <textarea id="list2-${id}" placeholder="Incolla lista..." onchange="updateProposalData(${id})"></textarea>
                    <button onclick="processList(${id}, 2)">Elabora Lista 2 (Check 12h)</button>
                    <div class="parsed-list-container" id="parsedList2-${id}"></div>
                </div>
            </div>
        `;
        container.appendChild(block);
        return id;
    }

    function removeProposalBlock(id) {
        const block = document.getElementById(`proposal-${id}`);
        if (block) block.remove();
        proposals = proposals.filter(p => p.id !== id);
    }

    function updateProposalData(id) {
        const proposal = proposals.find(p => p.id === id);
        if(proposal) {
            proposal.shortageDate = document.getElementById(`date1-${id}`).value;
            proposal.surplusDate = document.getElementById(`date2-${id}`).value;
            proposal.freeStaffList = document.getElementById(`list1-${id}`).value;
            proposal.reserveStaffList = document.getElementById(`list2-${id}`).value;
        }
    }

    // --- NUOVA LOGICA DI ELABORAZIONE LISTE ---
    function processList(id, listNumber) {
        const proposal = proposals.find(p => p.id === id);
        if (!proposal) return;

        updateProposalData(id); 
        const text = (listNumber === 1) ? proposal.freeStaffList : proposal.reserveStaffList;
        if (!text) { alert(`La Lista ${listNumber} √® vuota.`); return; }
        
        const parsedListContainer = document.getElementById(`parsedList${listNumber}-${id}`);
        
        // ATTIVA IL CONTROLLO 12 ORE SOLO PER LA LISTA 2
        const checkRest = (listNumber === 2);
        const processedData = parseEmployeeList(text, checkRest);
        
        if (listNumber === 1) { 
            proposal.processedFreeStaff = processedData; 
            proposal.isFreeProcessed = true; 
        } else { 
            proposal.processedReserveStaff = processedData;
            proposal.isReserveProcessed = true;
        }

        if (processedData.length === 0) {
            let msg = "Nessun collaboratore valido trovato.";
            if (checkRest) msg += " (Nessuno rispetta le 12h di riposo o formato orari non trovato)";
            parsedListContainer.innerHTML = `<p>${msg}</p>`; return;
        }

        const presto = processedData.filter(e => e.shiftType === 'Presto');
        const medio = processedData.filter(e => e.shiftType === 'Medio');
        const tardi = processedData.filter(e => e.shiftType === 'Tardi');
        
        let html = `<h4>Trovati ${processedData.length} collaboratori idonei:</h4>`;
        
        // Helper per visualizzare info riposo
        const printItem = (emp) => {
            let info = `<li><b>${emp.name}</b> (ID: ${emp.id})`;
            if (emp.restGap) {
                info += ` <span style="font-size:0.85em; color: green;">‚úÖ Riposo: ${emp.restGap}</span>`;
            }
            info += `</li>`;
            return info;
        };

        if (presto.length > 0) {
            html += '<h5>Turni Presto ‚òÄÔ∏è</h5><ul>';
            presto.forEach(emp => { html += printItem(emp); });
            html += '</ul>';
        }
        if (medio.length > 0) {
            html += '<h5>Turni Medio üïõ</h5><ul>';
            medio.forEach(emp => { html += printItem(emp); });
            html += '</ul>';
        }
        if (tardi.length > 0) {
            html += '<h5>Turni Tardi üåô</h5><ul>';
            tardi.forEach(emp => { html += printItem(emp); });
            html += '</ul>';
        }
        parsedListContainer.innerHTML = html;
    }

    // --- NUOVA FUNZIONE DI PARSING CON CONTROLLO ORARI ---
    function parseEmployeeList(text, checkRestRule = false) {
        const employees = [];
        // Divide per righe e rimuove quelle vuote
        const lines = text.split('\n').filter(line => line.trim() !== '');
        const idRegex = /\b(\d{6})\b/;

        lines.forEach(line => {
            // 1. Cerca ID
            const matchId = line.match(idRegex);
            
            if (matchId) {
                const id = matchId[1];
                
                // 2. Estrai Nome (Prende le due parole prima dell'ID o usa logica euristica)
                // Esempio: ... Rossi Marco 139454 ...
                const parts = line.substring(0, matchId.index).split(/\s+/).filter(p => p);
                let name = "Nome sconosciuto";
                if (parts.length >= 2) name = parts.slice(-2).join(' ');
                else if (parts.length === 1) name = parts[0];

                // 3. Determina Tipo Turno (dal testo della riga)
                let shiftType = 'Medio'; // Default
                const lowerLine = line.toLowerCase();
                if (lowerLine.includes('fr√ºh') || lowerLine.includes('presto')) shiftType = 'Presto';
                else if (lowerLine.includes('sp√§t') || lowerLine.includes('tardi')) shiftType = 'Tardi';

                // 4. LOGICA 12 ORE (Solo se checkRestRule √® true)
                let isEligible = true;
                let restGapStr = "";

                if (checkRestRule) {
                    // Cerca pattern orari: Due orari nel formato HH:MM nella stessa riga
                    // Es: 16:02 ... 04:21
                    // Usiamo una regex che cerca HH:MM ... HH:MM
                    const timeMatches = [...line.matchAll(/(\d{1,2}:\d{2})/g)];
                    
                    if (timeMatches.length >= 2) {
                        // Assumiamo che gli ultimi due orari rilevanti siano quelli di fine e inizio
                        // Nel tuo esempio: 16:02 (fine ieri) e 04:21 (inizio oggi)
                        // Spesso sono vicini al Deposito (CHI/BEL).
                        
                        // Prendiamo gli ultimi due trovati prima delle info di competenza, o i primi due dopo la data.
                        // Nel tuo esempio specifico: CHI 16:02 04:21. Sono consecutivi.
                        
                        // Strategia robusta: Cerchiamo una coppia di orari separati da spazi o tabulazioni
                        const pairMatch = line.match(/(\d{1,2}:\d{2})\s+(\d{1,2}:\d{2})/);
                        
                        if (pairMatch) {
                            const prevEndTime = pairMatch[1]; // es. 16:02
                            const nextStartTime = pairMatch[2]; // es. 04:21

                            const [h1, m1] = prevEndTime.split(':').map(Number);
                            const [h2, m2] = nextStartTime.split(':').map(Number);

                            const minutes1 = h1 * 60 + m1;
                            const minutes2 = h2 * 60 + m2;

                            // Calcolo differenza.
                            // Ipotesi: L'orario di fine (16:02) √® del giorno PRIMA rispetto all'inizio (04:21).
                            // Formula: (OrarioInizio + 24h) - OrarioFine
                            const minutesInDay = 1440;
                            const diffMinutes = (minutes2 + minutesInDay) - minutes1;
                            const diffHours = diffMinutes / 60;

                            // Controllo 12 ore (720 minuti)
                            if (diffMinutes < 720) {
                                isEligible = false;
                            } else {
                                const h = Math.floor(diffMinutes / 60);
                                const m = diffMinutes % 60;
                                restGapStr = `${h}h ${m}m`;
                            }
                        } else {
                            // Se non trova due orari vicini, potremmo decidere di includerlo con warning o escluderlo.
                            // Per sicurezza, se √® una lista di riserva e non ha orari chiari, lo includiamo ma senza tag verde.
                            // isEligible = true; 
                        }
                    }
                }

                if (isEligible) {
                    employees.push({ id, name, shiftType, restGap: restGapStr });
                }
            }
        });
        return employees;
    }

    function findAllSwapsAndGenerateEmails() {
        const resultsDiv = document.getElementById('swapResults');
        resultsDiv.style.display = 'block';
        resultsDiv.innerHTML = '';
        updateAllProposalsData();

        const consolidatedSwaps = new Map();
        let hasUnprocessedLists = false;

        for (const proposal of proposals) {
            if (!proposal.isFreeProcessed || !proposal.isReserveProcessed) {
                hasUnprocessedLists = true;
                continue; 
            }
            if (!proposal.shortageDate || !proposal.surplusDate) continue;

            const idsInReserveList = new Set(proposal.processedReserveStaff.map(emp => emp.id));
            const commonEmployees = proposal.processedFreeStaff.filter(emp => idsInReserveList.has(emp.id));

            for (const emp of commonEmployees) {
                const name = emp.name.split(' ').map(n => n.charAt(0).toUpperCase() + n.slice(1).toLowerCase()).join(' ');
                const swapInfo = {
                    proposalId: proposal.id,
                    dateToWork: proposal.shortageDate,
                    dateToFree: proposal.surplusDate
                };

                if (consolidatedSwaps.has(emp.id)) {
                    consolidatedSwaps.get(emp.id).swaps.push(swapInfo);
                } else {
                    consolidatedSwaps.set(emp.id, {
                        name: name,
                        id: emp.id,
                        swaps: [swapInfo]
                    });
                }
            }
        }

        if (hasUnprocessedLists) {
            resultsDiv.innerHTML = `<p style="color: var(--danger-color);">Attenzione: Elabora tutte le liste prima di analizzare.</p>`;
        }
        
        if (consolidatedSwaps.size > 0) {
            let html = `<h4>Risultato: ${consolidatedSwaps.size} Collaboratori Trovati</h4><ul>`;
            consolidatedSwaps.forEach(employeeData => {
                const monthObj = new Date(employeeData.swaps[0].dateToWork);
                const monthName = monthObj.toLocaleString('it-IT', { month: 'long' });
                const primoNome = employeeData.name.split(' ')[1] || employeeData.name.split(' ')[0];

                let body = `Buongiorno ${primoNome},\n\n` +
                         `Stiamo allestendo la distribuzione di ${monthName} e vorremmo chiederti disponibilit√† per i seguenti cambi:\n\n`;

                employeeData.swaps.forEach((swap, index) => {
                    const dWork = new Date(swap.dateToWork).toLocaleDateString('it-IT', { day: 'numeric', month: 'long' });
                    const dFree = new Date(swap.dateToFree).toLocaleDateString('it-IT', { day: 'numeric', month: 'long' });
                    body += `- Proposta #${index + 1}: Libero il ${dFree} per lavorare il ${dWork}\n`;
                });

                body += `\nGrazie mille.\n\nSaluti\nRipartizione del Personale FFS`;
                const subject = `Proposta cambio turni - ${employeeData.name}`;
                const mailtoLink = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
                
                html += `<li>
                            <span>${employeeData.name} (ID: ${employeeData.id}) - ${employeeData.swaps.length} scambi</span>
                            <a href="${mailtoLink}" style="text-decoration: none;"><button type="button">Invia Email</button></a>
                         </li>`;
            });
            html += '</ul>';
            resultsDiv.innerHTML += html; 
        } else if (!hasUnprocessedLists) {
            resultsDiv.innerHTML = '<h4 style="text-align: center;">Nessun collaboratore compatibile trovato.</h4>';
        }
    }

    function updateAllProposalsData() {
        for(const proposal of proposals) updateProposalData(proposal.id);
    }
    
    function init() { addProposalBlock(); }
    document.addEventListener('DOMContentLoaded', init);
</script>
